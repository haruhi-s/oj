(defun solve1 (input)
  (labels
      ((safe (i)
         (let* ((numbers i))
           (and (or (equal numbers (sort (copy-list numbers) #'<))
                    (equal numbers (sort (copy-list numbers) #'>)))
                (every (lambda (x) (<= 1 x 3)) (mapcar (compose #'abs #'-) (cdr numbers) numbers))))))
    (iter (for i in input)
      (when (safe i) (sum 1)))))

(defun solve2 (input)
  (labels
      ((safe (i)
         (let* ((numbers i))
           (and (or (equal numbers (sort (copy-list numbers) #'<))
                    (equal numbers (sort (copy-list numbers) #'>)))
                (every (lambda (x) (<= 1 x 3)) (mapcar (compose #'abs #'-) (cdr numbers) numbers)))))
       (safee (list)
         (iter (for j below (length list))
           (when (safe (append (subseq list 0 j) (subseq list (1+ j))))
             (return t)))))
    (iter (for i in input)
      (when (safee i) (sum 1)))))

(setq iterate::*always-declare-variables* t)

(defun solve11 (input)
  (declare (optimize (speed 3)))
  (labels ((safe (i)
             (iter
               (for (the fixnum a) in i)
               (for (the fixnum b) in (cdr i))
               (with (the boolean inc)) (with (the boolean dec))
               (when (< a b) (setq inc t))
               (when (> a b) (setq dec t))
               (when (= a b) (return nil))
               (when (and inc dec) (return nil))
               (unless (<= -3 (- a b) 3) (return nil))
               (finally (return t)))))
    (iter (for i in input)
      (when (safe i) (sum 1 into (the fixnum result)))
      (finally (return result)))))

(defun solve22 (input)
  (declare (optimize (speed 3)))
  (labels ((safe (i)
             (iter
               (for (the fixnum a) in i)
               (for (the fixnum b) in (cdr i))
               (with (the boolean inc)) (with (the boolean dec))
               (when (< a b) (setq inc t))
               (when (> a b) (setq dec t))
               (when (= a b) (return nil))
               (when (and inc dec) (return nil))
               (unless (<= -3 (- a b) 3) (return nil))
               (finally (return t))))
           (safee (i)
             (iter
               (for (the fixnum pos) below (length (the cons i)))
               (for (the fixnum a) in i)
               (for (the fixnum b) in (cdr i))
               (with (the boolean inc)) (with (the boolean dec))
               (when (< a b) (setq inc t))
               (when (> a b) (setq dec t))
               (when (= a b) (return (safe (append (subseq i (max 0 (1- pos)) pos) (subseq i (1+ pos))))))
               (when (and inc dec)
                 (return (or (safe (append (subseq i (max 0 (- pos 2)) (1- pos)) (subseq i pos)))
                             (safe (append (subseq i (max 0 (- pos 2)) pos) (subseq i (1+ pos))))
                             (safe (append (subseq i (1- pos) (1+ pos)) (subseq i (+ 2 pos))))
                             )))
               (unless (<= -3 (- a b) 3)
                 (return (or (safe (append (subseq i (max 0 (1- pos)) pos) (subseq i (1+ pos))))
                             (safe (append (subseq i pos (1+ pos)) (subseq i (+ 2 pos))))
                             )))
               (finally (return t)))))
    (iter (for i in input)
      (when (safee i) (sum 1 into (the fixnum result)))
      (finally (return result)))))

(defun parse (file)
  (mapcar (lambda (i) (mapcar #'parse-integer (str:split " " i))) (uiop:read-file-lines file)))

(defvar *input* (parse "day2.txt"))

(solve11 *input*)

(solve22 *input*)
